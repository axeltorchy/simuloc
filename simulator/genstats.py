#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""genstats module
Stats and graphics generation module.

Provide functions to generate statistics and visual representations of the
localization performance based on a log file generated by the genmeas module.


Author:         "Axel Torchy"
Copyright:      "Copyright 2020, Wizzilab"
Credits:        ["Axel Torchy", "Wizzilab"]
Version:        "1.0"
Email:          "axel@wizzilab.com"
Status:         "Production"
"""

import numpy as np
import json
import matplotlib.pyplot as plt

# List of public objects of the module, as interpreted by "import *"

__all__ = ['read_log_file', 'print_stats']



def read_log_file(filename):
    """
    Read the log file and saves the data
        - initial position
        - real tag position
        - inferred tag position
        - anchor selection method
        - localization method: minimization cost function + precision / LS / NLS
        - noise model
        - selected anchors and ranging measurements
        
    Parameters
    ----------
    filename : Name of the log file. There should be another file in the same
    folder named "options_{filename}" 
    
    Returns
    ----------
    data : dict indexed by the simulation UID (simu_uid) containing all the
    localization results needed to generate the stats.s
    
    metadata : dict indexed by the same simulation UID, contains all the
    metadata of the simulation: options, anchors positions, grid used for the
    simulation and number of tries for each of the grid positions.
    """
    
    metadata = {}
    
    # Save the metadata to a dict
    with open("options_" + filename, 'r') as f:
        for jsonOptions in f:
            result = json.loads(jsonOptions)
            
            simu_uid = result['simu_uid']
            if simu_uid not in metadata:
                metadata[simu_uid] = {}
                metadata[simu_uid]['simu_name'] = result['simu_name']
                metadata[simu_uid]['options'] = result['options']
                metadata[simu_uid]['anchors'] = result['anchors']
                metadata[simu_uid]['grids'] = [result['x_grid'],
                                               result['y_grid'],
                                               result['z_grid']]
                metadata[simu_uid]['N_tries'] = result['N_tries']
            
            else:
                raise Exception("Simulation UID already found. \
                                There must be a problem.")
            
    
    data = {}
    
    print("Opening file: " + filename)
    with open(filename, 'r') as f:
        count = 0
        for jsonLoc in f:
            result = json.loads(jsonLoc)
            
            simu_uid = result['simu_uid']
            
            # If this entry is the first corresponding to the simu_uid simu
            if simu_uid not in data:
                data[simu_uid] = {'res_pos': [],
                                  'tag_pos': [],
                                  'post_selected_anchors': []
                                  }
            
            data[simu_uid]['res_pos'].append(np.array([result['res_pos']['x'],
                                                       result['res_pos']['y'],
                                                       result['res_pos']['z']]))
            
            data[simu_uid]['tag_pos'].append(np.array([result['tag_pos']['x'],
                                                       result['tag_pos']['y'],
                                                       result['tag_pos']['z']]))
            
            
            # Compute initial position based on the initial guess method
            # specified in the options file.
            # Stats can be printed (e.g. average distance from the initial
            # point to check if the initial choice is relevant)
            # TODO
            
            
            data[simu_uid]['post_selected_anchors'].append(result['post_selected_anchors'])
            
            count += 1
            
            
    
    print(f"Processed {count} localization entries.")
        
    return data, metadata


def print_stats(data, metadata, do_plot = True):
    """
    Read the log file and prints relevant statistics for each simulation.
        
    Parameters
    ----------
    data : contains the localization results for several simulations.
    Indexed by simulation UID.
    metadata : contains the meta-information regarding the simulation,
    including the options (all information needed to distinguish two simulations
    from each other).
    do_plot : if True, matplotlib will be used to plot cumulative distribution
    functions and other diagrams. 
    
    Returns
    ----------
    None.
    """
    
    print(metadata)
    
    for simu_uid in data:
        simu_name = metadata[simu_uid]['simu_name']
        data[simu_uid]['res_pos'] = np.array(data[simu_uid]['res_pos'])
        data[simu_uid]['tag_pos'] = np.array(data[simu_uid]['tag_pos'])
        
        N_data = len(data[simu_uid]['res_pos'])
        
        options = metadata[simu_uid]['options']
        bnds = options['bounds']
        
        print("="*80)
        print("")
        print(f"\t Simulation: {simu_name} (UID: {simu_uid})  -  {N_data} entries")
        print("")
        print("* Method:           " , options['method'])
        print("* Initial guess:    " , options['initial_pos'])
        print("* Noise model:      " , options['noise_model'])
        print("* Noise params:     " , options['noise_params'])
        print("* Ranging distance: " , options['ranging_distance'])
        print("* Anchor selection: " , options['anchor_selection'])
        print("* Optimization:     " , options['optimization'])
        print("* Bounds:           " , f"{bnds[0][0]} < x < {bnds[0][1]}" +
              f" , {bnds[1][0]} < y < {bnds[1][1]} , {bnds[2][0]} < z < {bnds[2][1]}")
        print("* N anchors pre:    " , options['N_anchors_pre'])
        print("* N anchors post:   " , options['N_anchors_post'])
        print("")
        
        # print(data[simu_uid]['res_pos'])
        # print(data[simu_uid]['tag_pos'])
        # print(np.linalg.norm(data[simu_uid]['res_pos'] - data[simu_uid]['tag_pos'], axis=1))
        
        abs_errors = np.linalg.norm(data[simu_uid]['res_pos'] - data[simu_uid]['tag_pos'], axis=1)
        squ_errors = abs_errors ** 2
        
        
        abs_errors_2D = np.linalg.norm(data[simu_uid]['res_pos'][:, 0:2] - data[simu_uid]['tag_pos'][:, 0:2], axis=1)
        squ_errors_2D = abs_errors_2D ** 2
        
        
        # Mean measured tag-anchor distance
        TA_dist = []
        for i in range(N_data):
            for a in data[simu_uid]['post_selected_anchors'][i]:
                TA_dist.append(data[simu_uid]['post_selected_anchors'][i][a]['dst'])
        
        mean_TA_dist = np.mean(TA_dist)
        median_TA_dist = np.median(TA_dist)
            
        
        # 3D errors (XYZ)
        MSE_3D = np.mean(squ_errors)
        MedSE_3D = np.median(squ_errors)
        MAE_3D = np.mean(abs_errors)
        MedAE_3D = np.median(abs_errors)
        minAE_3D = np.min(abs_errors)
        maxAE_3D = np.max(abs_errors)
        
        # 3D errors (XYZ)
        MSE_2D = np.mean(squ_errors_2D)
        MedSE_2D = np.median(squ_errors_2D)
        MAE_2D = np.mean(abs_errors_2D)
        MedAE_2D = np.median(abs_errors_2D)
        minAE_2D = np.min(abs_errors_2D)
        maxAE_2D = np.max(abs_errors_2D)
        
        print("Tag-anchor distances:")
        print(f"* Mean tag-anchor distance:    {mean_TA_dist : .3f}")
        print(f"* Median tag-anchor distance:  {median_TA_dist : .3f}")
        
        print("")
        print("Errors in 3D (XYZ coordinates):")
        
        print(f"* Mean Squared Error (MSE):    {MSE_3D : .3f}")
        print(f"* Median Squared Error (MSE):  {MedSE_3D : .3f}")
        print(f"* Mean Absolute Error:         {MAE_3D : .3f}")
        print(f"* Median Absolute Error:       {MedAE_3D : .3f}")
        print(f"* Min Absolute Error:          {minAE_3D : .3f}")
        print(f"* Max Absolute Error:          {maxAE_3D : .3f}")
        print("")
        print("Errors in 2D (XY coordinates):")
        print(f"* Mean Squared Error (MSE):    {MSE_2D : .3f}")
        print(f"* Median Squared Error (MSE):  {MedSE_2D : .3f}")
        print(f"* Mean Absolute Error:         {MAE_2D : .3f}")
        print(f"* Median Absolute Error:       {MedAE_2D : .3f}")
        print(f"* Min Absolute Error:          {minAE_2D : .3f}")
        print(f"* Max Absolute Error:          {maxAE_2D : .3f}")
        print("")
        
        if do_plot:
            plt.figure(0)
            values, base = np.histogram(abs_errors, bins=3000)
            cumulative = np.cumsum(values)
            plt.plot(base[:-1], cumulative/N_data, label=simu_name)
            plt.figure(1)
            values, base = np.histogram(abs_errors_2D, bins=3000)
            cumulative = np.cumsum(values)
            plt.plot(base[:-1], cumulative/N_data, label=simu_name)
        
    if do_plot:
        plt.figure(0)
        # Set axis limits on x axis (min and max error)
        plt.xlim(0,2)
        plt.ylim(0,1)
        plt.xlabel("Absolute error in the 3D XYZ space ($m$)")
        plt.ylabel("Cumulative proportion")
        plt.title("Cumulative distribution functions")
        plt.legend()
            
        plt.figure(1)
        # Set axis limits on x axis (min and max error)
        plt.xlim(0,2)
        plt.ylim(0,1)
        plt.xlabel("Absolute error in the 2D XY plane ($m$)")
        plt.ylabel("Cumulative proportion")
        plt.title("Cumulative distribution functions")
        plt.legend()
        plt.show()
        
    
    print("="*80)
        